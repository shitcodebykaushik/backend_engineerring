# The backend from the engineering pov:_
Backend enginerring is form of art.
It all about the communication of backend .
Everything work under the one wire.
Performance latency and debug,bug everything works on the concept of connecting wires.
How the connection is established?
How these kernal choose the backend application?
WITHOUT KNOWING HOW Application how system work is horrible way of learning.
Never rely on orderning when it comes to backend that's why pipekine has been discontinued.

# Rewquest - Response
This is first communication design pattern for the communication

- Client sends a Request
  First of all client need to define what the request is and backend  need to understand it properly, this is continosly stream of a data. And the server need to look for the start of the data and end of the data.


- Server parses the Request 
  Server relly need to understand that where the request begin and where the request end .
  The cost of parsing the request is not a cheap .

- Server process the Request

- Server sends a response

- Client parses the Response and consume 

 # Where Request and Response  is used ?
  - Web,HTTP,DNS,SSH
  - RPC (remote procedure call)  
  - SQL and Database protocols 
  - API (REST/SOAP/GraphQL)
   Note in `REST` everything we define is request.

# Anatomy of Request/Response
 - A request structure is defined by the both client and server.
 - Request has a boundry 
 - Defined by a protocol and a message format



# Building an upload image with the request response

- 1. Send large request with the image (simple).
   - Each time server have to say ok ()

 - 2. Chunk image and send a rw=wquest per chunk (resumable). 
    - Once the connection is lost then also client can come back and say to the server hey lets do it agian.


Doesn't work evrywhere
 - Notification serveice (In this the backed have the knowledge but client doesn't)
 - Chatting application .
 - Very long request.
 - What if client disconnets.

  curl -v --trace out.txt http:://google.com
```RUST
 This is going to come for the request 
Warning: --trace overrides an earlier trace/verbose option
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   219  100   219    0     0    435      0 --:--:-- --:--:-- --:--:--   436<HTML><HEAD><meta http-equiv="content-type" content="text/html;charset=utf-8">
<TITLE>301 Moved</TITLE></HEAD><BODY>
<H1>301 Moved</H1>
The document has moved
<A HREF="http://www.google.com/">here</A>.
</BODY></HTML>


```
 -  cat out.txt
    - This will the details view of it .
    
```Rust
== Info: processing: http://google.com
== Info:   Trying [2404:6800:4002:821::200e]:80...
== Info: Connected to google.com (2404:6800:4002:821::200e) port 80
=> Send header, 73 bytes (0x49)
0000: 47 45 54 20 2f 20 48 54 54 50 2f 31 2e 31 0d 0a GET / HTTP/1.1..
0010: 48 6f 73 74 3a 20 67 6f 6f 67 6c 65 2e 63 6f 6d Host: google.com
0020: 0d 0a 55 73 65 72 2d 41 67 65 6e 74 3a 20 63 75 ..User-Agent: cu
0030: 72 6c 2f 38 2e 32 2e 31 0d 0a 41 63 63 65 70 74 rl/8.2.1..Accept
0040: 3a 20 2a 2f 2a 0d 0a 0d 0a                      : */*....
<= Recv header, 32 bytes (0x20)
0000: 48 54 54 50 2f 31 2e 31 20 33 30 31 20 4d 6f 76 HTTP/1.1 301 Mov
0010: 65 64 20 50 65 72 6d 61 6e 65 6e 74 6c 79 0d 0a ed Permanently..
<= Recv header, 34 bytes (0x22)
0000: 4c 6f 63 61 74 69 6f 6e 3a 20 68 74 74 70 3a 2f Location: http:/
0010: 2f 77 77 77 2e 67 6f 6f 67 6c 65 2e 63 6f 6d 2f /www.google.com/
0020: 0d 0a                                           ..
<= Recv header, 40 bytes (0x28)
0000: 43 6f 6e 74 65 6e 74 2d 54 79 70 65 3a 20 74 65 Content-Type: te
0010: 78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74 xt/html; charset
0020: 3d 55 54 46 2d 38 0d 0a                         =UTF-8..
<= Recv header, 245 bytes (0xf5)
0000: 43 6f 6e 74 65 6e 74 2d 53 65 63 75 72 69 74 79 Content-Security
0010: 2d 50 6f 6c 69 63 79 2d 52 65 70 6f 72 74 2d 4f -Policy-Report-O
0020: 6e 6c 79 3a 20 6f 62 6a 65 63 74 2d 73 72 63 20 nly: object-src
0030: 27 6e 6f 6e 65 27 3b 62 61 73 65 2d 75 72 69 20 'none';base-uri
0040: 27 73 65 6c 66 27 3b 73 63 72 69 70 74 2d 73 72 'self';script-sr
0050: 63 20 27 6e 6f 6e 63 65 2d 6b 59 76 7a 53 62 42 c 'nonce-kYvzSbB
0060: 30 32 35 74 73 76 77 6f 68 6d 64 2d 4c 42 67 27 025tsvwohmd-LBg'
0070: 20 27 73 74 72 69 63 74 2d 64 79 6e 61 6d 69 63  'strict-dynamic
0080: 27 20 27 72 65 70 6f 72 74 2d 73 61 6d 70 6c 65 ' 'report-sample
0090: 27 20 27 75 6e 73 61 66 65 2d 65 76 61 6c 27 20 ' 'unsafe-eval'
00a0: 27 75 6e 73 61 66 65 2d 69 6e 6c 69 6e 65 27 20 'unsafe-inline'
00b0: 68 74 74 70 73 3a 20 68 74 74 70 3a 3b 72 65 70 https: http:;rep
00c0: 6f 72 74 2d 75 72 69 20 68 74 74 70 73 3a 2f 2f ort-uri https://
00d0: 63 73 70 2e 77 69 74 68 67 6f 6f 67 6c 65 2e 63 csp.withgoogle.c
00e0: 6f 6d 2f 63 73 70 2f 67 77 73 2f 6f 74 68 65 72 om/csp/gws/other
00f0: 2d 68 70 0d 0a                                  -hp..
<= Recv header, 37 bytes (0x25)
0000: 44 61 74 65 3a 20 54 68 75 2c 20 31 38 20 41 70 Date: Thu, 18 Ap
0010: 72 20 32 30 32 34 20 31 34 3a 35 34 3a 30 31 20 r 2024 14:54:01
0020: 47 4d 54 0d 0a                                  GMT..
<= Recv header, 40 bytes (0x28)
0000: 45 78 70 69 72 65 73 3a 20 53 61 74 2c 20 31 38 Expires: Sat, 18
0010: 20 4d 61 79 20 32 30 32 34 20 31 34 3a 35 34 3a  May 2024 14:54:
0020: 30 31 20 47 4d 54 0d 0a                         01 GMT..
<= Recv header, 40 bytes (0x28)
0000: 43 61 63 68 65 2d 43 6f 6e 74 72 6f 6c 3a 20 70 Cache-Control: p
0010: 75 62 6c 69 63 2c 20 6d 61 78 2d 61 67 65 3d 32 ublic, max-age=2
0020: 35 39 32 30 30 30 0d 0a                         592000..
<= Recv header, 13 bytes (0xd)
0000: 53 65 72 76 65 72 3a 20 67 77 73 0d 0a          Server: gws..
<= Recv header, 21 bytes (0x15)
0000: 43 6f 6e 74 65 6e 74 2d 4c 65 6e 67 74 68 3a 20 Content-Length:
0010: 32 31 39 0d 0a                                  219..
<= Recv header, 21 bytes (0x15)
0000: 58 2d 58 53 53 2d 50 72 6f 74 65 63 74 69 6f 6e X-XSS-Protection
0010: 3a 20 30 0d 0a                                  : 0..
<= Recv header, 29 bytes (0x1d)
0000: 58 2d 46 72 61 6d 65 2d 4f 70 74 69 6f 6e 73 3a X-Frame-Options:
0010: 20 53 41 4d 45 4f 52 49 47 49 4e 0d 0a           SAMEORIGIN..
<= Recv header, 2 bytes (0x2)
0000: 0d 0a                                           ..
<= Recv data, 219 bytes (0xdb)
0000: 3c 48 54 4d 4c 3e 3c 48 45 41 44 3e 3c 6d 65 74 <HTML><HEAD><met
0010: 61 20 68 74 74 70 2d 65 71 75 69 76 3d 22 63 6f a http-equiv="co
0020: 6e 74 65 6e 74 2d 74 79 70 65 22 20 63 6f 6e 74 ntent-type" cont
0030: 65 6e 74 3d 22 74 65 78 74 2f 68 74 6d 6c 3b 63 ent="text/html;c
0040: 68 61 72 73 65 74 3d 75 74 66 2d 38 22 3e 0a 3c harset=utf-8">.<
0050: 54 49 54 4c 45 3e 33 30 31 20 4d 6f 76 65 64 3c TITLE>301 Moved<
0060: 2f 54 49 54 4c 45 3e 3c 2f 48 45 41 44 3e 3c 42 /TITLE></HEAD><B
0070: 4f 44 59 3e 0a 3c 48 31 3e 33 30 31 20 4d 6f 76 ODY>.<H1>301 Mov
0080: 65 64 3c 2f 48 31 3e 0a 54 68 65 20 64 6f 63 75 ed</H1>.The docu
0090: 6d 65 6e 74 20 68 61 73 20 6d 6f 76 65 64 0a 3c ment has moved.<
00a0: 41 20 48 52 45 46 3d 22 68 74 74 70 3a 2f 2f 77 A HREF="http://w
00b0: 77 77 2e 67 6f 6f 67 6c 65 2e 63 6f 6d 2f 22 3e ww.google.com/">
00c0: 68 65 72 65 3c 2f 41 3e 2e 0d 0a 3c 2f 42 4f 44 here</A>...</BOD
00d0: 59 3e 3c 2f 48 54 4d 4c 3e 0d 0a                Y></HTML>..
== Info: Connection #0 to host google.com left intact

```
# Synchronous Vs Asynchronous
 - In simple can i do work while waiting?
  Sync means they are goin in same way.
  Async means they are not going in same way. We should always prefer this as i want client to do something different and server to do something completely different.


- Synchronous I/O
   - Caller sends a request and blocks which means that one proceess need to finished first then only we go for next,it will block every line of code once the process has been implemented.Caller cannot execute any code meanwhile .

   - Receiver responds and caller will be unblocks 
   - Caller and receiver are in sync.
   - Synchronicity is a client property.
   - Asking question in meeeting where wait for the reply
- Asynchronous I/O
   - Sendinf email is best example where we ssent the mail once and works on different things.
  - Caller sends a request 
  - Caller can work until it gets a response.
  - Modern client libraries are async
  - Caller either :
     - Checks if the response is ready (epoll)
     - Receiver calls backs when its's done (io_uring)
     - Spins up a new thread that blocks 
  - Caller and reciever are not necessary in sync.
    Note try to implement the simple code in rust 

# Push 
This is another design pattern for comminication
 - Clients wants a real time notification from backend .In these case request/response doent fit well

   -  A user logged in 
   -  A meesage is just received
- A push model is good for certain case 
   - Clients connect server to a server
   - Servers sends data to the client
   - Clinet doesn't have to request anything 
   - Protocol must be biderectional
   - Used by RabbitMQ
   - Realtime as things happens the client will known the stuff 
   - Client must be online means that it should be physically connected to the server 
   - Client might not be able to handle as we pushinf the data to the client withouth carrying what client will do .
   - Polling is prefered  for the light client .
  
 - It is a bidirectional connection. And it requires the bidirectional protocol.

    

# Short Polling 
 The idea of polling is to make request and response.
  This is next paart of design pattern .
- When request/response isn't ideal
 - A request takes long time to process
   - Upload a youtube video
 - The backend wants to send a notification 
    - A user just logged in.
 - Polling is good communication method
 What is Short Polling.
 - Client sends a request
 - Server responds immediately with the handle
 - Server continues to process the request
 - Client uses that handle to check for status. Until the response was complited then only we respond.
 - Multiple "short" request response as polls.
 -Pros
  - Simple
  - Good for long running requests
  - Client can discconect
- Cons
  - Too chatty
  - Network bandwidth 
  - Wasted Backend resouces

# Long polling  
Where request/response & polling isnt ideal
 Kafka using this .
  Request is taking long, I will check with you later,But talk to me only when its ready.
  - Client sends a request .
  - Server responds immediately with a handle
  - Server continues to process the request 
  - Client uses that handle to check for status 
  - Server  DOES not reply until it has the response
  - So WE got a handle,we can disconnected
  - Some variation has timeouts too.
  - The way it works is totaly dofferent from short polling .
    Suppose a client sends a request then the server will send the request the id to the client ,as soon as the the client will ask to the server that is ID x is ready then server will not response to the client until the rewest is ready.
  - Pros
   - Less chatty and backend friendly
   - Client can still disconnect 
  - Cons
    - Not real time 

  # Server Sent Events 
  One request a very very long response 
  This is pure http model.
   - A response has start and end
   - Client sends a request
   - Server sends a logical events as part of response
   - Server never writes the end of the response
   - It is still a request but an unending response
   - Client parse the streams data looking for this events 
   - Works with the request/response (HTTP).
  -  Pros
     - Real time 
     - Compatible with the request/response
  - Cons 
     - Clients must be online
     - Clients might not be able to handle
     - Polling is preferred for light clients
     - HTTP/1.1 problem (6 connection)
  # Publish Subscribe 
   One publisher many readers      

   - Pros
    Scales w/ mutltiple recievers
    Great for microservice
    Loose Coupling
    Works while clients not running
  - Cons
    Message delivery issue (Two generals problems)
     Complexity
     Network  Saturation

  # Multiplexing vs Demultiplexing 
   HTTP/2,QUICE, Connection Pool ,MPTCP

   - Taking multiple connection and sending them into one. This is multiplexing reverse of this  will be demultiplexing.
   In mux More throughtput High backend resources (CPU for h2) .
    In demux we have less throughput low backend resources (simple h1 ) .

    -  Connection Pooling 
     In this we can spin up multiple connection and we can keep them hot .
     The order is not gurantee .
     In pipleing we have multi query support where we can support the multiple quert at once.
     Chrome allow up to 6 connection per domain , users rewuest are demultiplexed ,
     
  # Stateless and Stateful backend
   Is state stored  in the backend ?
   It is the style of the storing application in the backend .

 - Stateful
   Stores state about clients in its memorry
   Depends on the information being there

 - Stateless
   - Client is responsible to transfer the state with the every request
   - May store but can safely loose it 
   - Stateless backend can still store data somewhere else
   - Can you restart the backend during idle time while the client workflow continues to work.
   - The backend remian stateless but the system is stateful
   - Stateful vs Stateless protocol

    - The Protocols can be designed to store state
    - TCP is stateful
     - Sequence,Connection file descriptor
    - UDP is stateless
     - DNS send queryID in UDP to identify queries
     - QUIC send conncetionID to identify connection. [It is statefull in most of case but UDP is statelss]

    -  You can build a stateless prtocol on top of a statefull one and vise versa
    - HTTP on top of TCP 
    - If TCP breaks,HTTP blindly create another one
    - QUIC on top UDP 

  - Complete Stateless System
   - Stateless system are rare
   - State is carried with every request
   - A backend that relies completely on the input 
     - Check if input param is a prime number 
   - JWT (JSON Web Token)

  - Sidecar Pattern 
   Thick clients,Thicker backends .
   You have to know how to write the socket in a particular language , and you have to read all the complex.
   - Every prtocols require a library .
    - You need to use the library to built the particulare software .
    - `CURL` is client library as it know to talk to the client .
    - You can use the TLS LIBRARY (open ssl) and then to decrypt the data at server side  we can use the TLS(rUstSSL) .
    - grpc client grpc library the to decrpyt also we are using the same library .
    - Changing the library is hard .
    - Once you use the library your app is entrenched .
    - App & Library should be the same language 
    - Changing the library require retesting .
    - Breaking changes backward compatibilty
    - Adding fetaures to the library is hard .
    - Microservice suffer .

     // Use of proxy is left /
     


  
       



